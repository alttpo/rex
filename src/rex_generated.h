// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REX_REX_H_
#define FLATBUFFERS_GENERATED_REX_REX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace rex {

struct EnumerateChipsRequest;
struct EnumerateChipsRequestBuilder;

struct Chip;
struct ChipBuilder;

struct EnumerateChipsResponse;
struct EnumerateChipsResponseBuilder;

struct WriteMemory;
struct WriteMemoryBuilder;

struct ReadMemory;
struct ReadMemoryBuilder;

struct SetTimeout;
struct SetTimeoutBuilder;

struct WaitUntil;
struct WaitUntilBuilder;

struct WaitWhileZero;
struct WaitWhileZeroBuilder;

struct EnterProgramRequest;
struct EnterProgramRequestBuilder;

struct EnterProgramResponse;
struct EnterProgramResponseBuilder;

struct ExecuteProgramRequest;
struct ExecuteProgramRequestBuilder;

struct ExecuteProgramResponse;
struct ExecuteProgramResponseBuilder;

struct RequestTable;
struct RequestTableBuilder;

struct ResponseTable;
struct ResponseTableBuilder;

struct Message;
struct MessageBuilder;

enum ChipID : uint16_t {
  ChipID_SNES_WRAM = 0,
  ChipID_SNES_VRAM = 1,
  ChipID_SNES_CGRAM = 2,
  ChipID_SNES_OAM = 3,
  ChipID_SNES_APURAM = 4,
  ChipID_SNES_CART_ROM = 32,
  ChipID_SNES_CART_SRAM = 33,
  ChipID_SNES_CART_SA1_IRAM = 34,
  ChipID_SNES_CART_SA1_BWRAM = 35,
  ChipID_SNES_FXPAK_NMI_EXE = 64,
  ChipID_MIN = ChipID_SNES_WRAM,
  ChipID_MAX = ChipID_SNES_FXPAK_NMI_EXE
};

inline const ChipID (&EnumValuesChipID())[10] {
  static const ChipID values[] = {
    ChipID_SNES_WRAM,
    ChipID_SNES_VRAM,
    ChipID_SNES_CGRAM,
    ChipID_SNES_OAM,
    ChipID_SNES_APURAM,
    ChipID_SNES_CART_ROM,
    ChipID_SNES_CART_SRAM,
    ChipID_SNES_CART_SA1_IRAM,
    ChipID_SNES_CART_SA1_BWRAM,
    ChipID_SNES_FXPAK_NMI_EXE
  };
  return values;
}

inline const char *EnumNameChipID(ChipID e) {
  switch (e) {
    case ChipID_SNES_WRAM: return "SNES_WRAM";
    case ChipID_SNES_VRAM: return "SNES_VRAM";
    case ChipID_SNES_CGRAM: return "SNES_CGRAM";
    case ChipID_SNES_OAM: return "SNES_OAM";
    case ChipID_SNES_APURAM: return "SNES_APURAM";
    case ChipID_SNES_CART_ROM: return "SNES_CART_ROM";
    case ChipID_SNES_CART_SRAM: return "SNES_CART_SRAM";
    case ChipID_SNES_CART_SA1_IRAM: return "SNES_CART_SA1_IRAM";
    case ChipID_SNES_CART_SA1_BWRAM: return "SNES_CART_SA1_BWRAM";
    case ChipID_SNES_FXPAK_NMI_EXE: return "SNES_FXPAK_NMI_EXE";
    default: return "";
  }
}

enum Comparison : uint8_t {
  Comparison_Equal = 0,
  Comparison_NotEqual = 1,
  Comparison_LessThan = 2,
  Comparison_LessThanOrEqual = 3,
  Comparison_GreaterThan = 4,
  Comparison_GreaterThanOrEqual = 5,
  Comparison_MIN = Comparison_Equal,
  Comparison_MAX = Comparison_GreaterThanOrEqual
};

inline const Comparison (&EnumValuesComparison())[6] {
  static const Comparison values[] = {
    Comparison_Equal,
    Comparison_NotEqual,
    Comparison_LessThan,
    Comparison_LessThanOrEqual,
    Comparison_GreaterThan,
    Comparison_GreaterThanOrEqual
  };
  return values;
}

inline const char * const *EnumNamesComparison() {
  static const char * const names[7] = {
    "Equal",
    "NotEqual",
    "LessThan",
    "LessThanOrEqual",
    "GreaterThan",
    "GreaterThanOrEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameComparison(Comparison e) {
  if (::flatbuffers::IsOutRange(e, Comparison_Equal, Comparison_GreaterThanOrEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComparison()[index];
}

enum ErrorCode : uint8_t {
  ErrorCode_Success = 0,
  ErrorCode_UnknownChip = 1,
  ErrorCode_ChipNotReadable = 2,
  ErrorCode_ChipNotWritable = 3,
  ErrorCode_ChipAddressOutOfRange = 4,
  ErrorCode_PrgmInvalid = 5,
  ErrorCode_TimedOut = 254,
  ErrorCode_MIN = ErrorCode_Success,
  ErrorCode_MAX = ErrorCode_TimedOut
};

inline const ErrorCode (&EnumValuesErrorCode())[7] {
  static const ErrorCode values[] = {
    ErrorCode_Success,
    ErrorCode_UnknownChip,
    ErrorCode_ChipNotReadable,
    ErrorCode_ChipNotWritable,
    ErrorCode_ChipAddressOutOfRange,
    ErrorCode_PrgmInvalid,
    ErrorCode_TimedOut
  };
  return values;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  switch (e) {
    case ErrorCode_Success: return "Success";
    case ErrorCode_UnknownChip: return "UnknownChip";
    case ErrorCode_ChipNotReadable: return "ChipNotReadable";
    case ErrorCode_ChipNotWritable: return "ChipNotWritable";
    case ErrorCode_ChipAddressOutOfRange: return "ChipAddressOutOfRange";
    case ErrorCode_PrgmInvalid: return "PrgmInvalid";
    case ErrorCode_TimedOut: return "TimedOut";
    default: return "";
  }
}

enum ProgramInstruction : uint8_t {
  ProgramInstruction_NONE = 0,
  ProgramInstruction_WriteMemory = 1,
  ProgramInstruction_ReadMemory = 2,
  ProgramInstruction_SetTimeout = 3,
  ProgramInstruction_WaitUntil = 4,
  ProgramInstruction_WaitWhileZero = 5,
  ProgramInstruction_MIN = ProgramInstruction_NONE,
  ProgramInstruction_MAX = ProgramInstruction_WaitWhileZero
};

inline const ProgramInstruction (&EnumValuesProgramInstruction())[6] {
  static const ProgramInstruction values[] = {
    ProgramInstruction_NONE,
    ProgramInstruction_WriteMemory,
    ProgramInstruction_ReadMemory,
    ProgramInstruction_SetTimeout,
    ProgramInstruction_WaitUntil,
    ProgramInstruction_WaitWhileZero
  };
  return values;
}

inline const char * const *EnumNamesProgramInstruction() {
  static const char * const names[7] = {
    "NONE",
    "WriteMemory",
    "ReadMemory",
    "SetTimeout",
    "WaitUntil",
    "WaitWhileZero",
    nullptr
  };
  return names;
}

inline const char *EnumNameProgramInstruction(ProgramInstruction e) {
  if (::flatbuffers::IsOutRange(e, ProgramInstruction_NONE, ProgramInstruction_WaitWhileZero)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProgramInstruction()[index];
}

template<typename T> struct ProgramInstructionTraits {
  static const ProgramInstruction enum_value = ProgramInstruction_NONE;
};

template<> struct ProgramInstructionTraits<rex::WriteMemory> {
  static const ProgramInstruction enum_value = ProgramInstruction_WriteMemory;
};

template<> struct ProgramInstructionTraits<rex::ReadMemory> {
  static const ProgramInstruction enum_value = ProgramInstruction_ReadMemory;
};

template<> struct ProgramInstructionTraits<rex::SetTimeout> {
  static const ProgramInstruction enum_value = ProgramInstruction_SetTimeout;
};

template<> struct ProgramInstructionTraits<rex::WaitUntil> {
  static const ProgramInstruction enum_value = ProgramInstruction_WaitUntil;
};

template<> struct ProgramInstructionTraits<rex::WaitWhileZero> {
  static const ProgramInstruction enum_value = ProgramInstruction_WaitWhileZero;
};

bool VerifyProgramInstruction(::flatbuffers::Verifier &verifier, const void *obj, ProgramInstruction type);
bool VerifyProgramInstructionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

///////////////////////////////////
enum Request : uint8_t {
  Request_NONE = 0,
  Request_EnumerateChipsRequest = 1,
  Request_EnterProgramRequest = 2,
  Request_ExecuteProgramRequest = 3,
  Request_MIN = Request_NONE,
  Request_MAX = Request_ExecuteProgramRequest
};

inline const Request (&EnumValuesRequest())[4] {
  static const Request values[] = {
    Request_NONE,
    Request_EnumerateChipsRequest,
    Request_EnterProgramRequest,
    Request_ExecuteProgramRequest
  };
  return values;
}

inline const char * const *EnumNamesRequest() {
  static const char * const names[5] = {
    "NONE",
    "EnumerateChipsRequest",
    "EnterProgramRequest",
    "ExecuteProgramRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequest(Request e) {
  if (::flatbuffers::IsOutRange(e, Request_NONE, Request_ExecuteProgramRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequest()[index];
}

template<typename T> struct RequestTraits {
  static const Request enum_value = Request_NONE;
};

template<> struct RequestTraits<rex::EnumerateChipsRequest> {
  static const Request enum_value = Request_EnumerateChipsRequest;
};

template<> struct RequestTraits<rex::EnterProgramRequest> {
  static const Request enum_value = Request_EnterProgramRequest;
};

template<> struct RequestTraits<rex::ExecuteProgramRequest> {
  static const Request enum_value = Request_ExecuteProgramRequest;
};

bool VerifyRequest(::flatbuffers::Verifier &verifier, const void *obj, Request type);
bool VerifyRequestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Response : uint8_t {
  Response_NONE = 0,
  Response_EnumerateChipsResponse = 1,
  Response_EnterProgramResponse = 2,
  Response_ExecuteProgramResponse = 3,
  Response_MIN = Response_NONE,
  Response_MAX = Response_ExecuteProgramResponse
};

inline const Response (&EnumValuesResponse())[4] {
  static const Response values[] = {
    Response_NONE,
    Response_EnumerateChipsResponse,
    Response_EnterProgramResponse,
    Response_ExecuteProgramResponse
  };
  return values;
}

inline const char * const *EnumNamesResponse() {
  static const char * const names[5] = {
    "NONE",
    "EnumerateChipsResponse",
    "EnterProgramResponse",
    "ExecuteProgramResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponse(Response e) {
  if (::flatbuffers::IsOutRange(e, Response_NONE, Response_ExecuteProgramResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponse()[index];
}

template<typename T> struct ResponseTraits {
  static const Response enum_value = Response_NONE;
};

template<> struct ResponseTraits<rex::EnumerateChipsResponse> {
  static const Response enum_value = Response_EnumerateChipsResponse;
};

template<> struct ResponseTraits<rex::EnterProgramResponse> {
  static const Response enum_value = Response_EnterProgramResponse;
};

template<> struct ResponseTraits<rex::ExecuteProgramResponse> {
  static const Response enum_value = Response_ExecuteProgramResponse;
};

bool VerifyResponse(::flatbuffers::Verifier &verifier, const void *obj, Response type);
bool VerifyResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum RequestOrResponse : uint8_t {
  RequestOrResponse_NONE = 0,
  RequestOrResponse_RequestTable = 1,
  RequestOrResponse_ResponseTable = 2,
  RequestOrResponse_MIN = RequestOrResponse_NONE,
  RequestOrResponse_MAX = RequestOrResponse_ResponseTable
};

inline const RequestOrResponse (&EnumValuesRequestOrResponse())[3] {
  static const RequestOrResponse values[] = {
    RequestOrResponse_NONE,
    RequestOrResponse_RequestTable,
    RequestOrResponse_ResponseTable
  };
  return values;
}

inline const char * const *EnumNamesRequestOrResponse() {
  static const char * const names[4] = {
    "NONE",
    "RequestTable",
    "ResponseTable",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestOrResponse(RequestOrResponse e) {
  if (::flatbuffers::IsOutRange(e, RequestOrResponse_NONE, RequestOrResponse_ResponseTable)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestOrResponse()[index];
}

template<typename T> struct RequestOrResponseTraits {
  static const RequestOrResponse enum_value = RequestOrResponse_NONE;
};

template<> struct RequestOrResponseTraits<rex::RequestTable> {
  static const RequestOrResponse enum_value = RequestOrResponse_RequestTable;
};

template<> struct RequestOrResponseTraits<rex::ResponseTable> {
  static const RequestOrResponse enum_value = RequestOrResponse_ResponseTable;
};

bool VerifyRequestOrResponse(::flatbuffers::Verifier &verifier, const void *obj, RequestOrResponse type);
bool VerifyRequestOrResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

///////////////////////////////////
struct EnumerateChipsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerateChipsRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnumerateChipsRequestBuilder {
  typedef EnumerateChipsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnumerateChipsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerateChipsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerateChipsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerateChipsRequest> CreateEnumerateChipsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnumerateChipsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Chip FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_SIZE = 6,
    VT_FLAGS = 8,
    VT_NAME = 10
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ChipBuilder {
  typedef Chip Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(Chip::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Chip::VT_SIZE, size, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(Chip::VT_FLAGS, flags, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Chip::VT_NAME, name);
  }
  explicit ChipBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chip>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chip> CreateChip(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t size = 0,
    uint8_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ChipBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_size(size);
  builder_.add_chip_id(chip_id);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chip> CreateChipDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t size = 0,
    uint8_t flags = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rex::CreateChip(
      _fbb,
      chip_id,
      size,
      flags,
      name__);
}

struct EnumerateChipsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerateChipsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>> *chips() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>> *>(VT_CHIPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHIPS) &&
           verifier.VerifyVector(chips()) &&
           verifier.VerifyVectorOfTables(chips()) &&
           verifier.EndTable();
  }
};

struct EnumerateChipsResponseBuilder {
  typedef EnumerateChipsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chips(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>>> chips) {
    fbb_.AddOffset(EnumerateChipsResponse::VT_CHIPS, chips);
  }
  explicit EnumerateChipsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerateChipsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerateChipsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerateChipsResponse> CreateEnumerateChipsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>>> chips = 0) {
  EnumerateChipsResponseBuilder builder_(_fbb);
  builder_.add_chips(chips);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumerateChipsResponse> CreateEnumerateChipsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<rex::Chip>> *chips = nullptr) {
  auto chips__ = chips ? _fbb.CreateVector<::flatbuffers::Offset<rex::Chip>>(*chips) : 0;
  return rex::CreateEnumerateChipsResponse(
      _fbb,
      chips__);
}

///////////////////////////////////
struct WriteMemory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6,
    VT_INPUT_OFFSET = 8,
    VT_INPUT_SIZE_MINUS_1 = 10
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  uint16_t input_offset() const {
    return GetField<uint16_t>(VT_INPUT_OFFSET, 0);
  }
  uint8_t input_size_minus_1() const {
    return GetField<uint8_t>(VT_INPUT_SIZE_MINUS_1, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           VerifyField<uint16_t>(verifier, VT_INPUT_OFFSET, 2) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_SIZE_MINUS_1, 1) &&
           verifier.EndTable();
  }
};

struct WriteMemoryBuilder {
  typedef WriteMemory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(WriteMemory::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(WriteMemory::VT_CHIP_ADDR, chip_addr, 0);
  }
  void add_input_offset(uint16_t input_offset) {
    fbb_.AddElement<uint16_t>(WriteMemory::VT_INPUT_OFFSET, input_offset, 0);
  }
  void add_input_size_minus_1(uint8_t input_size_minus_1) {
    fbb_.AddElement<uint8_t>(WriteMemory::VT_INPUT_SIZE_MINUS_1, input_size_minus_1, 0);
  }
  explicit WriteMemoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemory> CreateWriteMemory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    uint16_t input_offset = 0,
    uint8_t input_size_minus_1 = 0) {
  WriteMemoryBuilder builder_(_fbb);
  builder_.add_chip_addr(chip_addr);
  builder_.add_input_offset(input_offset);
  builder_.add_chip_id(chip_id);
  builder_.add_input_size_minus_1(input_size_minus_1);
  return builder_.Finish();
}

struct ReadMemory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6,
    VT_OUTPUT_OFFSET = 8,
    VT_OUTPUT_SIZE_MINUS_1 = 10
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  uint16_t output_offset() const {
    return GetField<uint16_t>(VT_OUTPUT_OFFSET, 0);
  }
  uint8_t output_size_minus_1() const {
    return GetField<uint8_t>(VT_OUTPUT_SIZE_MINUS_1, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           VerifyField<uint16_t>(verifier, VT_OUTPUT_OFFSET, 2) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_SIZE_MINUS_1, 1) &&
           verifier.EndTable();
  }
};

struct ReadMemoryBuilder {
  typedef ReadMemory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(ReadMemory::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(ReadMemory::VT_CHIP_ADDR, chip_addr, 0);
  }
  void add_output_offset(uint16_t output_offset) {
    fbb_.AddElement<uint16_t>(ReadMemory::VT_OUTPUT_OFFSET, output_offset, 0);
  }
  void add_output_size_minus_1(uint8_t output_size_minus_1) {
    fbb_.AddElement<uint8_t>(ReadMemory::VT_OUTPUT_SIZE_MINUS_1, output_size_minus_1, 0);
  }
  explicit ReadMemoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemory> CreateReadMemory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    uint16_t output_offset = 0,
    uint8_t output_size_minus_1 = 0) {
  ReadMemoryBuilder builder_(_fbb);
  builder_.add_chip_addr(chip_addr);
  builder_.add_output_offset(output_offset);
  builder_.add_chip_id(chip_id);
  builder_.add_output_size_minus_1(output_size_minus_1);
  return builder_.Finish();
}

struct SetTimeout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetTimeoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLOCK_CYCLES = 4
  };
  uint32_t clock_cycles() const {
    return GetField<uint32_t>(VT_CLOCK_CYCLES, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLOCK_CYCLES, 4) &&
           verifier.EndTable();
  }
};

struct SetTimeoutBuilder {
  typedef SetTimeout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clock_cycles(uint32_t clock_cycles) {
    fbb_.AddElement<uint32_t>(SetTimeout::VT_CLOCK_CYCLES, clock_cycles, 0);
  }
  explicit SetTimeoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetTimeout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetTimeout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetTimeout> CreateSetTimeout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t clock_cycles = 0) {
  SetTimeoutBuilder builder_(_fbb);
  builder_.add_clock_cycles(clock_cycles);
  return builder_.Finish();
}

struct WaitUntil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WaitUntilBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WaitUntilBuilder {
  typedef WaitUntil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit WaitUntilBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WaitUntil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WaitUntil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WaitUntil> CreateWaitUntil(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  WaitUntilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WaitWhileZero FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WaitWhileZeroBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WaitWhileZeroBuilder {
  typedef WaitWhileZero Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit WaitWhileZeroBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WaitWhileZero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WaitWhileZero>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WaitWhileZero> CreateWaitWhileZero(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  WaitWhileZeroBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EnterProgramRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterProgramRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUCTIONS_TYPE = 4,
    VT_INSTRUCTIONS = 6
  };
  const ::flatbuffers::Vector<uint8_t> *instructions_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INSTRUCTIONS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *instructions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INSTRUCTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS_TYPE) &&
           verifier.VerifyVector(instructions_type()) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           VerifyProgramInstructionVector(verifier, instructions(), instructions_type()) &&
           verifier.EndTable();
  }
};

struct EnterProgramRequestBuilder {
  typedef EnterProgramRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instructions_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> instructions_type) {
    fbb_.AddOffset(EnterProgramRequest::VT_INSTRUCTIONS_TYPE, instructions_type);
  }
  void add_instructions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> instructions) {
    fbb_.AddOffset(EnterProgramRequest::VT_INSTRUCTIONS, instructions);
  }
  explicit EnterProgramRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterProgramRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterProgramRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterProgramRequest> CreateEnterProgramRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> instructions_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> instructions = 0) {
  EnterProgramRequestBuilder builder_(_fbb);
  builder_.add_instructions(instructions);
  builder_.add_instructions_type(instructions_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnterProgramRequest> CreateEnterProgramRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *instructions_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *instructions = nullptr) {
  auto instructions_type__ = instructions_type ? _fbb.CreateVector<uint8_t>(*instructions_type) : 0;
  auto instructions__ = instructions ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*instructions) : 0;
  return rex::CreateEnterProgramRequest(
      _fbb,
      instructions_type__,
      instructions__);
}

struct EnterProgramResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterProgramResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnterProgramResponseBuilder {
  typedef EnterProgramResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnterProgramResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterProgramResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterProgramResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterProgramResponse> CreateEnterProgramResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnterProgramResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

///////////////////////////////////
struct ExecuteProgramRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecuteProgramRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *input_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_DATA) &&
           verifier.VerifyVector(input_data()) &&
           verifier.EndTable();
  }
};

struct ExecuteProgramRequestBuilder {
  typedef ExecuteProgramRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> input_data) {
    fbb_.AddOffset(ExecuteProgramRequest::VT_INPUT_DATA, input_data);
  }
  explicit ExecuteProgramRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExecuteProgramRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExecuteProgramRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExecuteProgramRequest> CreateExecuteProgramRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> input_data = 0) {
  ExecuteProgramRequestBuilder builder_(_fbb);
  builder_.add_input_data(input_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ExecuteProgramRequest> CreateExecuteProgramRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *input_data = nullptr) {
  auto input_data__ = input_data ? _fbb.CreateVector<uint8_t>(*input_data) : 0;
  return rex::CreateExecuteProgramRequest(
      _fbb,
      input_data__);
}

struct ExecuteProgramResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecuteProgramResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *output_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT_DATA) &&
           verifier.VerifyVector(output_data()) &&
           verifier.EndTable();
  }
};

struct ExecuteProgramResponseBuilder {
  typedef ExecuteProgramResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_output_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> output_data) {
    fbb_.AddOffset(ExecuteProgramResponse::VT_OUTPUT_DATA, output_data);
  }
  explicit ExecuteProgramResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExecuteProgramResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExecuteProgramResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExecuteProgramResponse> CreateExecuteProgramResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> output_data = 0) {
  ExecuteProgramResponseBuilder builder_(_fbb);
  builder_.add_output_data(output_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ExecuteProgramResponse> CreateExecuteProgramResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *output_data = nullptr) {
  auto output_data__ = output_data ? _fbb.CreateVector<uint8_t>(*output_data) : 0;
  return rex::CreateExecuteProgramResponse(
      _fbb,
      output_data__);
}

struct RequestTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_TYPE = 4,
    VT_REQUEST = 6
  };
  rex::Request request_type() const {
    return static_cast<rex::Request>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const {
    return GetPointer<const void *>(VT_REQUEST);
  }
  template<typename T> const T *request_as() const;
  const rex::EnumerateChipsRequest *request_as_EnumerateChipsRequest() const {
    return request_type() == rex::Request_EnumerateChipsRequest ? static_cast<const rex::EnumerateChipsRequest *>(request()) : nullptr;
  }
  const rex::EnterProgramRequest *request_as_EnterProgramRequest() const {
    return request_type() == rex::Request_EnterProgramRequest ? static_cast<const rex::EnterProgramRequest *>(request()) : nullptr;
  }
  const rex::ExecuteProgramRequest *request_as_ExecuteProgramRequest() const {
    return request_type() == rex::Request_ExecuteProgramRequest ? static_cast<const rex::ExecuteProgramRequest *>(request()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyRequest(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rex::EnumerateChipsRequest *RequestTable::request_as<rex::EnumerateChipsRequest>() const {
  return request_as_EnumerateChipsRequest();
}

template<> inline const rex::EnterProgramRequest *RequestTable::request_as<rex::EnterProgramRequest>() const {
  return request_as_EnterProgramRequest();
}

template<> inline const rex::ExecuteProgramRequest *RequestTable::request_as<rex::ExecuteProgramRequest>() const {
  return request_as_ExecuteProgramRequest();
}

struct RequestTableBuilder {
  typedef RequestTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_request_type(rex::Request request_type) {
    fbb_.AddElement<uint8_t>(RequestTable::VT_REQUEST_TYPE, static_cast<uint8_t>(request_type), 0);
  }
  void add_request(::flatbuffers::Offset<void> request) {
    fbb_.AddOffset(RequestTable::VT_REQUEST, request);
  }
  explicit RequestTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestTable> CreateRequestTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::Request request_type = rex::Request_NONE,
    ::flatbuffers::Offset<void> request = 0) {
  RequestTableBuilder builder_(_fbb);
  builder_.add_request(request);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

struct ResponseTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  rex::Response response_type() const {
    return static_cast<rex::Response>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const rex::EnumerateChipsResponse *response_as_EnumerateChipsResponse() const {
    return response_type() == rex::Response_EnumerateChipsResponse ? static_cast<const rex::EnumerateChipsResponse *>(response()) : nullptr;
  }
  const rex::EnterProgramResponse *response_as_EnterProgramResponse() const {
    return response_type() == rex::Response_EnterProgramResponse ? static_cast<const rex::EnterProgramResponse *>(response()) : nullptr;
  }
  const rex::ExecuteProgramResponse *response_as_ExecuteProgramResponse() const {
    return response_type() == rex::Response_ExecuteProgramResponse ? static_cast<const rex::ExecuteProgramResponse *>(response()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponse(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rex::EnumerateChipsResponse *ResponseTable::response_as<rex::EnumerateChipsResponse>() const {
  return response_as_EnumerateChipsResponse();
}

template<> inline const rex::EnterProgramResponse *ResponseTable::response_as<rex::EnterProgramResponse>() const {
  return response_as_EnterProgramResponse();
}

template<> inline const rex::ExecuteProgramResponse *ResponseTable::response_as<rex::ExecuteProgramResponse>() const {
  return response_as_ExecuteProgramResponse();
}

struct ResponseTableBuilder {
  typedef ResponseTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_response_type(rex::Response response_type) {
    fbb_.AddElement<uint8_t>(ResponseTable::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(::flatbuffers::Offset<void> response) {
    fbb_.AddOffset(ResponseTable::VT_RESPONSE, response);
  }
  explicit ResponseTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseTable> CreateResponseTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::Response response_type = rex::Response_NONE,
    ::flatbuffers::Offset<void> response = 0) {
  ResponseTableBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  rex::RequestOrResponse message_type() const {
    return static_cast<rex::RequestOrResponse>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const rex::RequestTable *message_as_RequestTable() const {
    return message_type() == rex::RequestOrResponse_RequestTable ? static_cast<const rex::RequestTable *>(message()) : nullptr;
  }
  const rex::ResponseTable *message_as_ResponseTable() const {
    return message_type() == rex::RequestOrResponse_ResponseTable ? static_cast<const rex::ResponseTable *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyRequestOrResponse(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rex::RequestTable *Message::message_as<rex::RequestTable>() const {
  return message_as_RequestTable();
}

template<> inline const rex::ResponseTable *Message::message_as<rex::ResponseTable>() const {
  return message_as_ResponseTable();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(rex::RequestOrResponse message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::RequestOrResponse message_type = rex::RequestOrResponse_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyProgramInstruction(::flatbuffers::Verifier &verifier, const void *obj, ProgramInstruction type) {
  switch (type) {
    case ProgramInstruction_NONE: {
      return true;
    }
    case ProgramInstruction_WriteMemory: {
      auto ptr = reinterpret_cast<const rex::WriteMemory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_ReadMemory: {
      auto ptr = reinterpret_cast<const rex::ReadMemory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_SetTimeout: {
      auto ptr = reinterpret_cast<const rex::SetTimeout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_WaitUntil: {
      auto ptr = reinterpret_cast<const rex::WaitUntil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_WaitWhileZero: {
      auto ptr = reinterpret_cast<const rex::WaitWhileZero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyProgramInstructionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyProgramInstruction(
        verifier,  values->Get(i), types->GetEnum<ProgramInstruction>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequest(::flatbuffers::Verifier &verifier, const void *obj, Request type) {
  switch (type) {
    case Request_NONE: {
      return true;
    }
    case Request_EnumerateChipsRequest: {
      auto ptr = reinterpret_cast<const rex::EnumerateChipsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Request_EnterProgramRequest: {
      auto ptr = reinterpret_cast<const rex::EnterProgramRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Request_ExecuteProgramRequest: {
      auto ptr = reinterpret_cast<const rex::ExecuteProgramRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequest(
        verifier,  values->Get(i), types->GetEnum<Request>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponse(::flatbuffers::Verifier &verifier, const void *obj, Response type) {
  switch (type) {
    case Response_NONE: {
      return true;
    }
    case Response_EnumerateChipsResponse: {
      auto ptr = reinterpret_cast<const rex::EnumerateChipsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Response_EnterProgramResponse: {
      auto ptr = reinterpret_cast<const rex::EnterProgramResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Response_ExecuteProgramResponse: {
      auto ptr = reinterpret_cast<const rex::ExecuteProgramResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponse(
        verifier,  values->Get(i), types->GetEnum<Response>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequestOrResponse(::flatbuffers::Verifier &verifier, const void *obj, RequestOrResponse type) {
  switch (type) {
    case RequestOrResponse_NONE: {
      return true;
    }
    case RequestOrResponse_RequestTable: {
      auto ptr = reinterpret_cast<const rex::RequestTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestOrResponse_ResponseTable: {
      auto ptr = reinterpret_cast<const rex::ResponseTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestOrResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestOrResponse(
        verifier,  values->Get(i), types->GetEnum<RequestOrResponse>(i))) {
      return false;
    }
  }
  return true;
}

inline const rex::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<rex::Message>(buf);
}

inline const rex::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<rex::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rex::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rex::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rex::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rex::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace rex

#endif  // FLATBUFFERS_GENERATED_REX_REX_H_
