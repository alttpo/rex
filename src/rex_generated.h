// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REX_REX_H_
#define FLATBUFFERS_GENERATED_REX_REX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace rex {

struct EnumerateChipsRequest;
struct EnumerateChipsRequestBuilder;

struct Chip;
struct ChipBuilder;

struct EnumerateChipsResponse;
struct EnumerateChipsResponseBuilder;

struct WriteMemory;
struct WriteMemoryBuilder;

struct ReadMemory;
struct ReadMemoryBuilder;

struct SetTimeout;
struct SetTimeoutBuilder;

struct WaitUntil;
struct WaitUntilBuilder;

struct WaitWhileZero;
struct WaitWhileZeroBuilder;

struct EnterProgramRequest;
struct EnterProgramRequestBuilder;

struct EnterProgramResponse;
struct EnterProgramResponseBuilder;

struct ExecuteProgramRequest;
struct ExecuteProgramRequestBuilder;

struct InstructionOutput;
struct InstructionOutputBuilder;

struct ExecuteProgramResponse;
struct ExecuteProgramResponseBuilder;

struct RequestMessage;
struct RequestMessageBuilder;

struct ResponseMessage;
struct ResponseMessageBuilder;

enum ChipID : uint16_t {
  ChipID_SNES_WRAM = 0,
  ChipID_SNES_VRAM = 1,
  ChipID_SNES_CGRAM = 2,
  ChipID_SNES_OAM = 3,
  ChipID_SNES_APURAM = 4,
  ChipID_SNES_CART_ROM = 32,
  ChipID_SNES_CART_SRAM = 33,
  ChipID_SNES_CART_SA1_IRAM = 34,
  ChipID_SNES_CART_SA1_BWRAM = 35,
  ChipID_SNES_FXPAK_NMI_EXE = 64,
  ChipID_MIN = ChipID_SNES_WRAM,
  ChipID_MAX = ChipID_SNES_FXPAK_NMI_EXE
};

inline const ChipID (&EnumValuesChipID())[10] {
  static const ChipID values[] = {
    ChipID_SNES_WRAM,
    ChipID_SNES_VRAM,
    ChipID_SNES_CGRAM,
    ChipID_SNES_OAM,
    ChipID_SNES_APURAM,
    ChipID_SNES_CART_ROM,
    ChipID_SNES_CART_SRAM,
    ChipID_SNES_CART_SA1_IRAM,
    ChipID_SNES_CART_SA1_BWRAM,
    ChipID_SNES_FXPAK_NMI_EXE
  };
  return values;
}

inline const char *EnumNameChipID(ChipID e) {
  switch (e) {
    case ChipID_SNES_WRAM: return "SNES_WRAM";
    case ChipID_SNES_VRAM: return "SNES_VRAM";
    case ChipID_SNES_CGRAM: return "SNES_CGRAM";
    case ChipID_SNES_OAM: return "SNES_OAM";
    case ChipID_SNES_APURAM: return "SNES_APURAM";
    case ChipID_SNES_CART_ROM: return "SNES_CART_ROM";
    case ChipID_SNES_CART_SRAM: return "SNES_CART_SRAM";
    case ChipID_SNES_CART_SA1_IRAM: return "SNES_CART_SA1_IRAM";
    case ChipID_SNES_CART_SA1_BWRAM: return "SNES_CART_SA1_BWRAM";
    case ChipID_SNES_FXPAK_NMI_EXE: return "SNES_FXPAK_NMI_EXE";
    default: return "";
  }
}

enum Comparison : uint8_t {
  Comparison_Equal = 0,
  Comparison_NotEqual = 1,
  Comparison_LessThan = 2,
  Comparison_LessThanOrEqual = 3,
  Comparison_GreaterThan = 4,
  Comparison_GreaterThanOrEqual = 5,
  Comparison_MIN = Comparison_Equal,
  Comparison_MAX = Comparison_GreaterThanOrEqual
};

inline const Comparison (&EnumValuesComparison())[6] {
  static const Comparison values[] = {
    Comparison_Equal,
    Comparison_NotEqual,
    Comparison_LessThan,
    Comparison_LessThanOrEqual,
    Comparison_GreaterThan,
    Comparison_GreaterThanOrEqual
  };
  return values;
}

inline const char * const *EnumNamesComparison() {
  static const char * const names[7] = {
    "Equal",
    "NotEqual",
    "LessThan",
    "LessThanOrEqual",
    "GreaterThan",
    "GreaterThanOrEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameComparison(Comparison e) {
  if (::flatbuffers::IsOutRange(e, Comparison_Equal, Comparison_GreaterThanOrEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComparison()[index];
}

enum ErrorCode : uint8_t {
  ErrorCode_Success = 0,
  ErrorCode_UnknownChip = 1,
  ErrorCode_ChipNotReadable = 2,
  ErrorCode_ChipNotWritable = 3,
  ErrorCode_ChipAddressOutOfRange = 4,
  ErrorCode_PrgmInvalid = 5,
  ErrorCode_TimedOut = 254,
  ErrorCode_MIN = ErrorCode_Success,
  ErrorCode_MAX = ErrorCode_TimedOut
};

inline const ErrorCode (&EnumValuesErrorCode())[7] {
  static const ErrorCode values[] = {
    ErrorCode_Success,
    ErrorCode_UnknownChip,
    ErrorCode_ChipNotReadable,
    ErrorCode_ChipNotWritable,
    ErrorCode_ChipAddressOutOfRange,
    ErrorCode_PrgmInvalid,
    ErrorCode_TimedOut
  };
  return values;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  switch (e) {
    case ErrorCode_Success: return "Success";
    case ErrorCode_UnknownChip: return "UnknownChip";
    case ErrorCode_ChipNotReadable: return "ChipNotReadable";
    case ErrorCode_ChipNotWritable: return "ChipNotWritable";
    case ErrorCode_ChipAddressOutOfRange: return "ChipAddressOutOfRange";
    case ErrorCode_PrgmInvalid: return "PrgmInvalid";
    case ErrorCode_TimedOut: return "TimedOut";
    default: return "";
  }
}

enum ProgramInstruction : uint8_t {
  ProgramInstruction_NONE = 0,
  ProgramInstruction_WriteMemory = 1,
  ProgramInstruction_ReadMemory = 2,
  ProgramInstruction_SetTimeout = 3,
  ProgramInstruction_WaitUntil = 4,
  ProgramInstruction_WaitWhileZero = 5,
  ProgramInstruction_MIN = ProgramInstruction_NONE,
  ProgramInstruction_MAX = ProgramInstruction_WaitWhileZero
};

inline const ProgramInstruction (&EnumValuesProgramInstruction())[6] {
  static const ProgramInstruction values[] = {
    ProgramInstruction_NONE,
    ProgramInstruction_WriteMemory,
    ProgramInstruction_ReadMemory,
    ProgramInstruction_SetTimeout,
    ProgramInstruction_WaitUntil,
    ProgramInstruction_WaitWhileZero
  };
  return values;
}

inline const char * const *EnumNamesProgramInstruction() {
  static const char * const names[7] = {
    "NONE",
    "WriteMemory",
    "ReadMemory",
    "SetTimeout",
    "WaitUntil",
    "WaitWhileZero",
    nullptr
  };
  return names;
}

inline const char *EnumNameProgramInstruction(ProgramInstruction e) {
  if (::flatbuffers::IsOutRange(e, ProgramInstruction_NONE, ProgramInstruction_WaitWhileZero)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProgramInstruction()[index];
}

template<typename T> struct ProgramInstructionTraits {
  static const ProgramInstruction enum_value = ProgramInstruction_NONE;
};

template<> struct ProgramInstructionTraits<rex::WriteMemory> {
  static const ProgramInstruction enum_value = ProgramInstruction_WriteMemory;
};

template<> struct ProgramInstructionTraits<rex::ReadMemory> {
  static const ProgramInstruction enum_value = ProgramInstruction_ReadMemory;
};

template<> struct ProgramInstructionTraits<rex::SetTimeout> {
  static const ProgramInstruction enum_value = ProgramInstruction_SetTimeout;
};

template<> struct ProgramInstructionTraits<rex::WaitUntil> {
  static const ProgramInstruction enum_value = ProgramInstruction_WaitUntil;
};

template<> struct ProgramInstructionTraits<rex::WaitWhileZero> {
  static const ProgramInstruction enum_value = ProgramInstruction_WaitWhileZero;
};

bool VerifyProgramInstruction(::flatbuffers::Verifier &verifier, const void *obj, ProgramInstruction type);
bool VerifyProgramInstructionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

///////////////////////////////////
enum Request : uint8_t {
  Request_NONE = 0,
  Request_EnumerateChipsRequest = 1,
  Request_EnterProgramRequest = 2,
  Request_ExecuteProgramRequest = 3,
  Request_MIN = Request_NONE,
  Request_MAX = Request_ExecuteProgramRequest
};

inline const Request (&EnumValuesRequest())[4] {
  static const Request values[] = {
    Request_NONE,
    Request_EnumerateChipsRequest,
    Request_EnterProgramRequest,
    Request_ExecuteProgramRequest
  };
  return values;
}

inline const char * const *EnumNamesRequest() {
  static const char * const names[5] = {
    "NONE",
    "EnumerateChipsRequest",
    "EnterProgramRequest",
    "ExecuteProgramRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequest(Request e) {
  if (::flatbuffers::IsOutRange(e, Request_NONE, Request_ExecuteProgramRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequest()[index];
}

template<typename T> struct RequestTraits {
  static const Request enum_value = Request_NONE;
};

template<> struct RequestTraits<rex::EnumerateChipsRequest> {
  static const Request enum_value = Request_EnumerateChipsRequest;
};

template<> struct RequestTraits<rex::EnterProgramRequest> {
  static const Request enum_value = Request_EnterProgramRequest;
};

template<> struct RequestTraits<rex::ExecuteProgramRequest> {
  static const Request enum_value = Request_ExecuteProgramRequest;
};

bool VerifyRequest(::flatbuffers::Verifier &verifier, const void *obj, Request type);
bool VerifyRequestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Response : uint8_t {
  Response_NONE = 0,
  Response_EnumerateChipsResponse = 1,
  Response_EnterProgramResponse = 2,
  Response_ExecuteProgramResponse = 3,
  Response_MIN = Response_NONE,
  Response_MAX = Response_ExecuteProgramResponse
};

inline const Response (&EnumValuesResponse())[4] {
  static const Response values[] = {
    Response_NONE,
    Response_EnumerateChipsResponse,
    Response_EnterProgramResponse,
    Response_ExecuteProgramResponse
  };
  return values;
}

inline const char * const *EnumNamesResponse() {
  static const char * const names[5] = {
    "NONE",
    "EnumerateChipsResponse",
    "EnterProgramResponse",
    "ExecuteProgramResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponse(Response e) {
  if (::flatbuffers::IsOutRange(e, Response_NONE, Response_ExecuteProgramResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponse()[index];
}

template<typename T> struct ResponseTraits {
  static const Response enum_value = Response_NONE;
};

template<> struct ResponseTraits<rex::EnumerateChipsResponse> {
  static const Response enum_value = Response_EnumerateChipsResponse;
};

template<> struct ResponseTraits<rex::EnterProgramResponse> {
  static const Response enum_value = Response_EnterProgramResponse;
};

template<> struct ResponseTraits<rex::ExecuteProgramResponse> {
  static const Response enum_value = Response_ExecuteProgramResponse;
};

bool VerifyResponse(::flatbuffers::Verifier &verifier, const void *obj, Response type);
bool VerifyResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

///////////////////////////////////
struct EnumerateChipsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerateChipsRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnumerateChipsRequestBuilder {
  typedef EnumerateChipsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnumerateChipsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerateChipsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerateChipsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerateChipsRequest> CreateEnumerateChipsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnumerateChipsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Chip FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_SIZE = 6,
    VT_FLAGS = 8,
    VT_NAME = 10
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ChipBuilder {
  typedef Chip Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(Chip::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Chip::VT_SIZE, size, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(Chip::VT_FLAGS, flags, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Chip::VT_NAME, name);
  }
  explicit ChipBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chip>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chip> CreateChip(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t size = 0,
    uint8_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ChipBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_size(size);
  builder_.add_chip_id(chip_id);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chip> CreateChipDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t size = 0,
    uint8_t flags = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rex::CreateChip(
      _fbb,
      chip_id,
      size,
      flags,
      name__);
}

struct EnumerateChipsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerateChipsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>> *chips() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>> *>(VT_CHIPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHIPS) &&
           verifier.VerifyVector(chips()) &&
           verifier.VerifyVectorOfTables(chips()) &&
           verifier.EndTable();
  }
};

struct EnumerateChipsResponseBuilder {
  typedef EnumerateChipsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chips(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>>> chips) {
    fbb_.AddOffset(EnumerateChipsResponse::VT_CHIPS, chips);
  }
  explicit EnumerateChipsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerateChipsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerateChipsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerateChipsResponse> CreateEnumerateChipsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::Chip>>> chips = 0) {
  EnumerateChipsResponseBuilder builder_(_fbb);
  builder_.add_chips(chips);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumerateChipsResponse> CreateEnumerateChipsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<rex::Chip>> *chips = nullptr) {
  auto chips__ = chips ? _fbb.CreateVector<::flatbuffers::Offset<rex::Chip>>(*chips) : 0;
  return rex::CreateEnumerateChipsResponse(
      _fbb,
      chips__);
}

///////////////////////////////////
struct WriteMemory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6,
    VT_DATA = 8
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct WriteMemoryBuilder {
  typedef WriteMemory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(WriteMemory::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(WriteMemory::VT_CHIP_ADDR, chip_addr, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteMemory::VT_DATA, data);
  }
  explicit WriteMemoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemory> CreateWriteMemory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteMemoryBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_chip_addr(chip_addr);
  builder_.add_chip_id(chip_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteMemory> CreateWriteMemoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rex::CreateWriteMemory(
      _fbb,
      chip_id,
      chip_addr,
      data__);
}

struct ReadMemory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6,
    VT_SIZE = 8
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  uint16_t size() const {
    return GetField<uint16_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           VerifyField<uint16_t>(verifier, VT_SIZE, 2) &&
           verifier.EndTable();
  }
};

struct ReadMemoryBuilder {
  typedef ReadMemory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(ReadMemory::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(ReadMemory::VT_CHIP_ADDR, chip_addr, 0);
  }
  void add_size(uint16_t size) {
    fbb_.AddElement<uint16_t>(ReadMemory::VT_SIZE, size, 0);
  }
  explicit ReadMemoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemory> CreateReadMemory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    uint16_t size = 0) {
  ReadMemoryBuilder builder_(_fbb);
  builder_.add_chip_addr(chip_addr);
  builder_.add_size(size);
  builder_.add_chip_id(chip_id);
  return builder_.Finish();
}

struct SetTimeout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetTimeoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLOCK_CYCLES = 4
  };
  uint32_t clock_cycles() const {
    return GetField<uint32_t>(VT_CLOCK_CYCLES, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLOCK_CYCLES, 4) &&
           verifier.EndTable();
  }
};

struct SetTimeoutBuilder {
  typedef SetTimeout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clock_cycles(uint32_t clock_cycles) {
    fbb_.AddElement<uint32_t>(SetTimeout::VT_CLOCK_CYCLES, clock_cycles, 0);
  }
  explicit SetTimeoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetTimeout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetTimeout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetTimeout> CreateSetTimeout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t clock_cycles = 0) {
  SetTimeoutBuilder builder_(_fbb);
  builder_.add_clock_cycles(clock_cycles);
  return builder_.Finish();
}

struct WaitUntil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WaitUntilBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6,
    VT_CMP_FUNC = 8,
    VT_MASK = 10,
    VT_CMP_VALUE = 12
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  rex::Comparison cmp_func() const {
    return static_cast<rex::Comparison>(GetField<uint8_t>(VT_CMP_FUNC, 0));
  }
  uint8_t mask() const {
    return GetField<uint8_t>(VT_MASK, 0);
  }
  uint8_t cmp_value() const {
    return GetField<uint8_t>(VT_CMP_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           VerifyField<uint8_t>(verifier, VT_CMP_FUNC, 1) &&
           VerifyField<uint8_t>(verifier, VT_MASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_CMP_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct WaitUntilBuilder {
  typedef WaitUntil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(WaitUntil::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(WaitUntil::VT_CHIP_ADDR, chip_addr, 0);
  }
  void add_cmp_func(rex::Comparison cmp_func) {
    fbb_.AddElement<uint8_t>(WaitUntil::VT_CMP_FUNC, static_cast<uint8_t>(cmp_func), 0);
  }
  void add_mask(uint8_t mask) {
    fbb_.AddElement<uint8_t>(WaitUntil::VT_MASK, mask, 0);
  }
  void add_cmp_value(uint8_t cmp_value) {
    fbb_.AddElement<uint8_t>(WaitUntil::VT_CMP_VALUE, cmp_value, 0);
  }
  explicit WaitUntilBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WaitUntil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WaitUntil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WaitUntil> CreateWaitUntil(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0,
    rex::Comparison cmp_func = rex::Comparison_Equal,
    uint8_t mask = 0,
    uint8_t cmp_value = 0) {
  WaitUntilBuilder builder_(_fbb);
  builder_.add_chip_addr(chip_addr);
  builder_.add_chip_id(chip_id);
  builder_.add_cmp_value(cmp_value);
  builder_.add_mask(mask);
  builder_.add_cmp_func(cmp_func);
  return builder_.Finish();
}

struct WaitWhileZero FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WaitWhileZeroBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIP_ID = 4,
    VT_CHIP_ADDR = 6
  };
  rex::ChipID chip_id() const {
    return static_cast<rex::ChipID>(GetField<uint16_t>(VT_CHIP_ID, 0));
  }
  uint32_t chip_addr() const {
    return GetField<uint32_t>(VT_CHIP_ADDR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_ADDR, 4) &&
           verifier.EndTable();
  }
};

struct WaitWhileZeroBuilder {
  typedef WaitWhileZero Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chip_id(rex::ChipID chip_id) {
    fbb_.AddElement<uint16_t>(WaitWhileZero::VT_CHIP_ID, static_cast<uint16_t>(chip_id), 0);
  }
  void add_chip_addr(uint32_t chip_addr) {
    fbb_.AddElement<uint32_t>(WaitWhileZero::VT_CHIP_ADDR, chip_addr, 0);
  }
  explicit WaitWhileZeroBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WaitWhileZero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WaitWhileZero>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WaitWhileZero> CreateWaitWhileZero(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ChipID chip_id = rex::ChipID_SNES_WRAM,
    uint32_t chip_addr = 0) {
  WaitWhileZeroBuilder builder_(_fbb);
  builder_.add_chip_addr(chip_addr);
  builder_.add_chip_id(chip_id);
  return builder_.Finish();
}

struct EnterProgramRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterProgramRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUCTIONS_TYPE = 4,
    VT_INSTRUCTIONS = 6
  };
  const ::flatbuffers::Vector<uint8_t> *instructions_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INSTRUCTIONS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *instructions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INSTRUCTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS_TYPE) &&
           verifier.VerifyVector(instructions_type()) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           VerifyProgramInstructionVector(verifier, instructions(), instructions_type()) &&
           verifier.EndTable();
  }
};

struct EnterProgramRequestBuilder {
  typedef EnterProgramRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instructions_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> instructions_type) {
    fbb_.AddOffset(EnterProgramRequest::VT_INSTRUCTIONS_TYPE, instructions_type);
  }
  void add_instructions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> instructions) {
    fbb_.AddOffset(EnterProgramRequest::VT_INSTRUCTIONS, instructions);
  }
  explicit EnterProgramRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterProgramRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterProgramRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterProgramRequest> CreateEnterProgramRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> instructions_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> instructions = 0) {
  EnterProgramRequestBuilder builder_(_fbb);
  builder_.add_instructions(instructions);
  builder_.add_instructions_type(instructions_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnterProgramRequest> CreateEnterProgramRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *instructions_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *instructions = nullptr) {
  auto instructions_type__ = instructions_type ? _fbb.CreateVector<uint8_t>(*instructions_type) : 0;
  auto instructions__ = instructions ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*instructions) : 0;
  return rex::CreateEnterProgramRequest(
      _fbb,
      instructions_type__,
      instructions__);
}

struct EnterProgramResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterProgramResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnterProgramResponseBuilder {
  typedef EnterProgramResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnterProgramResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterProgramResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterProgramResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterProgramResponse> CreateEnterProgramResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnterProgramResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

///////////////////////////////////
struct ExecuteProgramRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecuteProgramRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExecuteProgramRequestBuilder {
  typedef ExecuteProgramRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ExecuteProgramRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExecuteProgramRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExecuteProgramRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExecuteProgramRequest> CreateExecuteProgramRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ExecuteProgramRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct InstructionOutput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionOutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_DATA = 6
  };
  rex::ErrorCode error_code() const {
    return static_cast<rex::ErrorCode>(GetField<uint8_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_CODE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct InstructionOutputBuilder {
  typedef InstructionOutput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(rex::ErrorCode error_code) {
    fbb_.AddElement<uint8_t>(InstructionOutput::VT_ERROR_CODE, static_cast<uint8_t>(error_code), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(InstructionOutput::VT_DATA, data);
  }
  explicit InstructionOutputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstructionOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstructionOutput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstructionOutput> CreateInstructionOutput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ErrorCode error_code = rex::ErrorCode_Success,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  InstructionOutputBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstructionOutput> CreateInstructionOutputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::ErrorCode error_code = rex::ErrorCode_Success,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rex::CreateInstructionOutput(
      _fbb,
      error_code,
      data__);
}

struct ExecuteProgramResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecuteProgramResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<rex::InstructionOutput>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rex::InstructionOutput>> *>(VT_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
};

struct ExecuteProgramResponseBuilder {
  typedef ExecuteProgramResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::InstructionOutput>>> outputs) {
    fbb_.AddOffset(ExecuteProgramResponse::VT_OUTPUTS, outputs);
  }
  explicit ExecuteProgramResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExecuteProgramResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExecuteProgramResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExecuteProgramResponse> CreateExecuteProgramResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rex::InstructionOutput>>> outputs = 0) {
  ExecuteProgramResponseBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ExecuteProgramResponse> CreateExecuteProgramResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<rex::InstructionOutput>> *outputs = nullptr) {
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<rex::InstructionOutput>>(*outputs) : 0;
  return rex::CreateExecuteProgramResponse(
      _fbb,
      outputs__);
}

struct RequestMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_TYPE = 4,
    VT_REQUEST = 6
  };
  rex::Request request_type() const {
    return static_cast<rex::Request>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const {
    return GetPointer<const void *>(VT_REQUEST);
  }
  template<typename T> const T *request_as() const;
  const rex::EnumerateChipsRequest *request_as_EnumerateChipsRequest() const {
    return request_type() == rex::Request_EnumerateChipsRequest ? static_cast<const rex::EnumerateChipsRequest *>(request()) : nullptr;
  }
  const rex::EnterProgramRequest *request_as_EnterProgramRequest() const {
    return request_type() == rex::Request_EnterProgramRequest ? static_cast<const rex::EnterProgramRequest *>(request()) : nullptr;
  }
  const rex::ExecuteProgramRequest *request_as_ExecuteProgramRequest() const {
    return request_type() == rex::Request_ExecuteProgramRequest ? static_cast<const rex::ExecuteProgramRequest *>(request()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyRequest(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rex::EnumerateChipsRequest *RequestMessage::request_as<rex::EnumerateChipsRequest>() const {
  return request_as_EnumerateChipsRequest();
}

template<> inline const rex::EnterProgramRequest *RequestMessage::request_as<rex::EnterProgramRequest>() const {
  return request_as_EnterProgramRequest();
}

template<> inline const rex::ExecuteProgramRequest *RequestMessage::request_as<rex::ExecuteProgramRequest>() const {
  return request_as_ExecuteProgramRequest();
}

struct RequestMessageBuilder {
  typedef RequestMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_request_type(rex::Request request_type) {
    fbb_.AddElement<uint8_t>(RequestMessage::VT_REQUEST_TYPE, static_cast<uint8_t>(request_type), 0);
  }
  void add_request(::flatbuffers::Offset<void> request) {
    fbb_.AddOffset(RequestMessage::VT_REQUEST, request);
  }
  explicit RequestMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMessage> CreateRequestMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::Request request_type = rex::Request_NONE,
    ::flatbuffers::Offset<void> request = 0) {
  RequestMessageBuilder builder_(_fbb);
  builder_.add_request(request);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

struct ResponseMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  rex::Response response_type() const {
    return static_cast<rex::Response>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const rex::EnumerateChipsResponse *response_as_EnumerateChipsResponse() const {
    return response_type() == rex::Response_EnumerateChipsResponse ? static_cast<const rex::EnumerateChipsResponse *>(response()) : nullptr;
  }
  const rex::EnterProgramResponse *response_as_EnterProgramResponse() const {
    return response_type() == rex::Response_EnterProgramResponse ? static_cast<const rex::EnterProgramResponse *>(response()) : nullptr;
  }
  const rex::ExecuteProgramResponse *response_as_ExecuteProgramResponse() const {
    return response_type() == rex::Response_ExecuteProgramResponse ? static_cast<const rex::ExecuteProgramResponse *>(response()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponse(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rex::EnumerateChipsResponse *ResponseMessage::response_as<rex::EnumerateChipsResponse>() const {
  return response_as_EnumerateChipsResponse();
}

template<> inline const rex::EnterProgramResponse *ResponseMessage::response_as<rex::EnterProgramResponse>() const {
  return response_as_EnterProgramResponse();
}

template<> inline const rex::ExecuteProgramResponse *ResponseMessage::response_as<rex::ExecuteProgramResponse>() const {
  return response_as_ExecuteProgramResponse();
}

struct ResponseMessageBuilder {
  typedef ResponseMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_response_type(rex::Response response_type) {
    fbb_.AddElement<uint8_t>(ResponseMessage::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(::flatbuffers::Offset<void> response) {
    fbb_.AddOffset(ResponseMessage::VT_RESPONSE, response);
  }
  explicit ResponseMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMessage> CreateResponseMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rex::Response response_type = rex::Response_NONE,
    ::flatbuffers::Offset<void> response = 0) {
  ResponseMessageBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline bool VerifyProgramInstruction(::flatbuffers::Verifier &verifier, const void *obj, ProgramInstruction type) {
  switch (type) {
    case ProgramInstruction_NONE: {
      return true;
    }
    case ProgramInstruction_WriteMemory: {
      auto ptr = reinterpret_cast<const rex::WriteMemory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_ReadMemory: {
      auto ptr = reinterpret_cast<const rex::ReadMemory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_SetTimeout: {
      auto ptr = reinterpret_cast<const rex::SetTimeout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_WaitUntil: {
      auto ptr = reinterpret_cast<const rex::WaitUntil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProgramInstruction_WaitWhileZero: {
      auto ptr = reinterpret_cast<const rex::WaitWhileZero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyProgramInstructionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyProgramInstruction(
        verifier,  values->Get(i), types->GetEnum<ProgramInstruction>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequest(::flatbuffers::Verifier &verifier, const void *obj, Request type) {
  switch (type) {
    case Request_NONE: {
      return true;
    }
    case Request_EnumerateChipsRequest: {
      auto ptr = reinterpret_cast<const rex::EnumerateChipsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Request_EnterProgramRequest: {
      auto ptr = reinterpret_cast<const rex::EnterProgramRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Request_ExecuteProgramRequest: {
      auto ptr = reinterpret_cast<const rex::ExecuteProgramRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequest(
        verifier,  values->Get(i), types->GetEnum<Request>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponse(::flatbuffers::Verifier &verifier, const void *obj, Response type) {
  switch (type) {
    case Response_NONE: {
      return true;
    }
    case Response_EnumerateChipsResponse: {
      auto ptr = reinterpret_cast<const rex::EnumerateChipsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Response_EnterProgramResponse: {
      auto ptr = reinterpret_cast<const rex::EnterProgramResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Response_ExecuteProgramResponse: {
      auto ptr = reinterpret_cast<const rex::ExecuteProgramResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponseVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponse(
        verifier,  values->Get(i), types->GetEnum<Response>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace rex

#endif  // FLATBUFFERS_GENERATED_REX_REX_H_
